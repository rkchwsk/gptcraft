<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Voxel Flight ‚Äî tablet edition + inventory</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #c7d5ee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #1b2230;
    }
    canvas { touch-action: none; display:block; }

    #overlay {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: radial-gradient(circle at 50% 0%, rgba(160,190,255,0.4), rgba(0,0,0,0.6));
      z-index: 10;
      flex-direction: column;
      text-align: center;
      color: #f7f9ff;
    }
    #overlay h1 { margin: 0 0 12px; font-size: 26px; letter-spacing: .06em; text-transform: uppercase; }
    #overlay p { margin: 4px 0; opacity: 0.9; font-size: 14px; }
    #startBtn {
      margin-top: 16px;
      padding: 10px 22px;
      border-radius: 999px;
      border: 1px solid rgba(170,190,255,0.8);
      background: linear-gradient(135deg,#5074ff,#46b0ff);
      color: #f7fbff;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 0 24px rgba(40,120,255,0.75);
    }
    #startBtn:hover { filter: brightness(1.08); }

    #hud {
      position: fixed;
      inset: 0;
      color: #101522;
      text-shadow: 0 1px 3px rgba(255,255,255,0.4);
      font-size: 13px;
      pointer-events: none;
    }

    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 16px;
      height: 16px;
      margin-left: -8px;
      margin-top: -8px;
      pointer-events: none;
    }
    #crosshair:before,
    #crosshair:after {
      content: "";
      position: absolute;
      left: 7px;
      top: 0;
      width: 2px;
      height: 16px;
      background: rgba(10,20,40,0.8);
    }
    #crosshair:after {
      transform: rotate(90deg);
      transform-origin: 50% 50%;
    }

    #help {
      position: absolute;
      left: 12px;
      top: 12px;
      max-width: 270px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(230,236,255,0.85);
      border: 1px solid rgba(120,140,200,0.7);
      backdrop-filter: blur(6px);
      line-height: 1.4;
      pointer-events: none;
    }
    #help b { font-weight: 600; }

    #hotbar {
      position: absolute;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(230,236,255,0.9);
      border: 1px solid rgba(120,140,200,0.7);
      backdrop-filter: blur(8px);
      pointer-events: auto;
    }
    .slot {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 1px solid rgba(110,120,160,0.7);
      position: relative;
      box-sizing: border-box;
      pointer-events: auto;
      user-select: none;
    }
    .slot .color {
      position: absolute;
      inset: 4px;
      border-radius: 4px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12);
    }
    .slot.active {
      border-color: #ffb200;
      box-shadow: 0 0 8px rgba(255,178,0,0.9);
    }
    .slot .num {
      position: absolute;
      right: 3px;
      bottom: 1px;
      font-size: 9px;
      opacity: 0.7;
      pointer-events:none;
    }
    .slot .cnt {
      position: absolute;
      left: 3px;
      bottom: 1px;
      font-size: 9px;
      opacity: 0.9;
      background: rgba(255,255,255,0.7);
      border-radius: 4px;
      padding: 0 3px;
      pointer-events:none;
    }

    #info {
      position: absolute;
      right: 12px;
      top: 12px;
      padding: 6px 9px;
      border-radius: 10px;
      background: rgba(230,236,255,0.92);
      border: 1px solid rgba(120,140,200,0.7);
      backdrop-filter: blur(6px);
      min-width: 140px;
      text-align: right;
      pointer-events: none;
    }
    #info div { margin: 2px 0; }

    #modeToggle, #invBtn {
      position: absolute;
      right: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(230,236,255,0.92);
      border: 1px solid rgba(120,140,200,0.8);
      backdrop-filter: blur(6px);
      font-size: 12px;
      font-weight: 700;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      user-select: none;
      touch-action: none;
    }
    #modeToggle { bottom: 140px; }
    #invBtn { bottom: 188px; }

    #modeToggle span.icon, #invBtn span.icon { font-size: 14px; }

    /* ===== Inventory overlay ===== */
    #invOverlay {
      position: fixed;
      inset: 0;
      background: rgba(10,16,30,0.35);
      backdrop-filter: blur(4px);
      z-index: 20;
      display: none;
      pointer-events: auto;
    }
    #invPanel {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      width: min(560px, calc(100vw - 22px));
      max-height: min(70vh, 520px);
      overflow: auto;
      background: rgba(240,246,255,0.95);
      border: 1px solid rgba(120,140,200,0.85);
      border-radius: 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      padding: 12px;
    }
    #invHeader {
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 10px;
    }
    #invHeader b { font-size: 14px; }
    #invClose {
      pointer-events: auto;
      border: 1px solid rgba(120,140,200,0.9);
      background: white;
      border-radius: 10px;
      padding: 6px 10px;
      font-weight: 700;
      cursor: pointer;
      touch-action: none;
    }

    #invGrid {
      display: grid;
      grid-template-columns: repeat(5, minmax(90px, 1fr));
      gap: 8px;
    }
    @media (max-width: 520px){
      #invGrid { grid-template-columns: repeat(3, minmax(92px, 1fr)); }
    }
    .invItem {
      border: 1px solid rgba(120,140,200,0.75);
      border-radius: 12px;
      padding: 8px;
      background: rgba(255,255,255,0.85);
      display:flex;
      gap: 10px;
      align-items:center;
      cursor: pointer;
      user-select:none;
      touch-action: manipulation;
    }
    .invItem.active {
      outline: 2px solid #ffb200;
      box-shadow: 0 0 12px rgba(255,178,0,0.35);
    }
    .invSwatch {
      width: 26px; height: 26px;
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
      flex: 0 0 auto;
    }
    .invMeta { min-width: 0; }
    .invName { font-weight: 800; font-size: 12px; line-height: 1.1; }
    .invCount { font-size: 12px; opacity: .85; }

    /* ===== Touch controls ===== */
    #joystickLeft {
      position: absolute;
      left: 16px;
      bottom: 20px;
      width: 120px;
      height: 120px;
      pointer-events: auto;
      touch-action: none;
    }
    #joystickLeft .outer {
      position: absolute; inset: 0;
      border-radius: 50%;
      border: 1px solid rgba(50,60,90,0.9);
      background: radial-gradient(circle, rgba(240,245,255,0.95), rgba(210,220,245,0.9));
      box-shadow: 0 0 12px rgba(0,0,0,0.25);
      opacity: 0.92;
    }
    #joystickLeft .inner {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      margin-left: -25px;
      margin-top: -25px;
      background: radial-gradient(circle, #ffffff, #ccd5ff);
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      transform: translate(0,0);
    }
    #btnUp, #btnDown {
      position: absolute;
      right: 22px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 1px solid rgba(50,60,90,0.9);
      background: radial-gradient(circle, #ffffff, #d4e3ff);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      color: #1b2230;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }
    #btnUp { bottom: 90px; }
    #btnDown { bottom: 24px; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Voxel Flight</h1>
    <p><b>W A S D</b> –∏–ª–∏ –ª–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ</p>
    <p><b>–ü—Ä–æ–±–µ–ª / ‚ñ≤</b> ‚Äî –≤–≤–µ—Ä—Ö, <b>Shift / ‚ñº</b> ‚Äî –≤–Ω–∏–∑</p>
    <p><b>–¢–∞–ø –ø–æ —Å–ª–æ—Ç—É</b> –≤–Ω–∏–∑—É ‚Äî –≤—ã–±–æ—Ä –±–ª–æ–∫–∞</p>
    <p><b>–ö–Ω–æ–ø–∫–∞ "–†–µ–∂–∏–º"</b> ‚Äî —Å—Ç–∞–≤–∏—Ç—å / –ª–æ–º–∞—Ç—å</p>
    <p><b>üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</b>: E (–ü–ö) –∏–ª–∏ –∫–Ω–æ–ø–∫–∞ üéí</p>
    <button id="startBtn">–ù–∞—á–∞—Ç—å</button>
  </div>

  <div id="hud">
    <div id="crosshair"></div>

    <div id="help">
      <b>–†–µ–∂–∏–º –ø–æ–ª—ë—Ç–∞</b> (–∫–∞–∫ –∫—Ä–µ–∞—Ç–∏–≤).<br>
      –ë–ª–æ–∫–∏ –∏ –≤–æ–¥–∞ ‚Äî –æ–±—ä—ë–º–Ω—ã–µ, –ø—Ä–æ–π—Ç–∏ —Å–∫–≤–æ–∑—å –Ω–∏—Ö –Ω–µ–ª—å–∑—è.<br><br>
      –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: –ª–æ–º–∞–π –±–ª–æ–∫–∏ ‚Üí –æ–Ω–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è. –°—Ç–∞–≤—å –±–ª–æ–∫–∏ ‚Üí —Ä–∞—Å—Ö–æ–¥—É—é—Ç—Å—è.
    </div>

    <div id="hotbar"></div>

    <div id="info">
      <div>XYZ: <span id="pos"></span></div>
      <div>–ë–ª–æ–∫: <span id="blockName"></span></div>
    </div>

    <div id="invBtn">
      <span class="icon">üéí</span>
      <span>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</span>
    </div>

    <div id="modeToggle">
      <span class="icon">üß±</span>
      <span id="modeText">–†–µ–∂–∏–º: –ª–æ–º–∞—Ç—å</span>
    </div>

    <div id="joystickLeft">
      <div class="outer"></div>
      <div class="inner" id="joystickHandle"></div>
    </div>
    <div id="btnUp">‚ñ≤</div>
    <div id="btnDown">‚ñº</div>
  </div>

  <!-- Inventory UI -->
  <div id="invOverlay">
    <div id="invPanel">
      <div id="invHeader">
        <b>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å (—Ç–∞–ø/–∫–ª–∏–∫ –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É ‚Äî –≤—ã–±—Ä–∞—Ç—å)</b>
        <button id="invClose">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
      <div id="invGrid"></div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdde7ff);
    scene.fog = new THREE.Fog(0xdde7ff, 50, 200);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);

    // Player carrier
    const player = new THREE.Object3D();
    player.position.set(0, 8, 20);
    player.add(camera);
    scene.add(player);

    // Pointer lock desktop
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');

    let isPointerLocked = false;
    let yaw = 0;
    let pitch = 0;
    const yawPitchEuler = new THREE.Euler(0,0,0,'YXZ');
    const PI_2 = Math.PI / 2;

    startBtn.addEventListener('click', () => {
      if (isTouchDevice) {
        overlay.style.display = 'none';
      } else {
        renderer.domElement.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === renderer.domElement;
      if (isPointerLocked) overlay.style.display = 'none';
      else if (!isTouchDevice) overlay.style.display = 'flex';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isPointerLocked) return;
      if (inventoryOpen) return;
      const sensitivity = 0.0025;
      yaw   -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-PI_2 + 0.1, Math.min(PI_2 - 0.1, pitch));
      yawPitchEuler.set(pitch, yaw, 0, 'YXZ');
      camera.quaternion.setFromEuler(yawPitchEuler);
    });

    // Lights
    scene.add(new THREE.HemisphereLight(0xe6f0ff, 0x99b08f, 0.8));

    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(40, 80, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 200;
    sun.shadow.camera.left = -80;
    sun.shadow.camera.right = 80;
    sun.shadow.camera.top = 80;
    sun.shadow.camera.bottom = -80;
    scene.add(sun);

    const farGround = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      new THREE.MeshStandardMaterial({ color: 0xb7c9a6, roughness: 1 })
    );
    farGround.rotation.x = -Math.PI/2;
    farGround.position.y = -10;
    farGround.receiveShadow = true;
    scene.add(farGround);

    // ===== Blocks =====
    const blockTypes = [
      { id: 0, name: "–¢—Ä–∞–≤–∞",      color: 0x7bcf7b, rough: 0.9,  metal: 0.0 },
      { id: 1, name: "–ó–µ–º–ª—è",      color: 0x9d6645, rough: 1.0,  metal: 0.0 },
      { id: 2, name: "–ö–∞–º–µ–Ω—å",     color: 0x9096a3, rough: 0.8,  metal: 0.1 },
      { id: 3, name: "–ü–µ—Å–æ–∫",      color: 0xefe0b4, rough: 0.95, metal: 0.0 },
      { id: 4, name: "–î–æ—Å–∫–∏",      color: 0xc3925b, rough: 0.7,  metal: 0.05 },
      { id: 5, name: "–õ–∏—Å—Ç–≤–∞",     color: 0x4a9155, rough: 0.9,  metal: 0.0, alpha: 0.95 },
      { id: 6, name: "–ì—Ä–∞–Ω–∏—Ç",     color: 0xbf7b69, rough: 0.75, metal: 0.18 },
      { id: 7, name: "–†—É–¥–∞",       color: 0x8f93a5, rough: 0.65, metal: 0.35, emissive: 0x4458ff, emissiveIntensity: 0.3 },
      { id: 8, name: "–°–≤–µ—Ç—è—â–∏–π—Å—è", color: 0xfaf5d0, rough: 0.15, metal: 0.2,  emissive: 0xfff2b0, emissiveIntensity: 0.9 },
      { id: 9, name: "–í–æ–¥–∞",       color: 0x3a84f0, rough: 0.15, metal: 0.0, transparent: true, opacity: 0.55, isWater: true }
    ];

    const blockMaterials = {};
    for (const t of blockTypes) {
      const mat = new THREE.MeshStandardMaterial({
        color: t.color,
        roughness: t.rough,
        metalness: t.metal,
        emissive: t.emissive || 0x000000,
        emissiveIntensity: t.emissiveIntensity || 0,
        transparent: !!t.transparent,
        opacity: t.opacity || 1
      });
      blockMaterials[t.id] = mat;
    }

    const blockGeo = new THREE.BoxGeometry(1,1,1);
    const worldBlocks = new Map(); // key "x,y,z" -> mesh
    function keyFromXYZ(x,y,z){ return x + "," + y + "," + z; }

    function addBlock(x,y,z,blockId) {
      const key = keyFromXYZ(x,y,z);
      if (worldBlocks.has(key)) return false;
      const mat = blockMaterials[blockId] || blockMaterials[1];
      const mesh = new THREE.Mesh(blockGeo, mat);
      mesh.position.set(x+0.5, y+0.5, z+0.5);
      mesh.castShadow = !blockTypes[blockId]?.isWater;
      mesh.receiveShadow = true;
      mesh.userData.blockId = blockId;
      scene.add(mesh);
      worldBlocks.set(key, mesh);
      return true;
    }

    function removeBlock(x,y,z){
      const key = keyFromXYZ(x,y,z);
      const m = worldBlocks.get(key);
      if(!m) return null;
      const id = m.userData.blockId;
      scene.remove(m);
      worldBlocks.delete(key);
      return id;
    }

    // ===== Inventory logic =====
    const invCounts = new Map(); // blockId -> count
    function getCount(id){ return invCounts.get(id) ?? 0; }
    function setCount(id, v){ invCounts.set(id, Math.max(0, Math.floor(v))); }
    function addToInv(id, delta){ setCount(id, getCount(id) + delta); }
    function canSpend(id, delta){ return getCount(id) >= delta; }
    function spend(id, delta){
      if(!canSpend(id, delta)) return false;
      setCount(id, getCount(id) - delta);
      return true;
    }

    // –°—Ç–∞—Ä—Ç–æ–≤—ã–π –Ω–∞–±–æ—Ä (—á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ —Å—Ç—Ä–æ–∏—Ç—å —Å—Ä–∞–∑—É)
    for (const t of blockTypes) {
      // –≤–æ–¥—ã –º–µ–Ω—å—à–µ, –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ –±–æ–ª—å—à–µ
      setCount(t.id, t.isWater ? 64 : 256);
    }

    // ===== World generation =====
    const WORLD_SIZE = 32;
    const HALF = WORLD_SIZE/2;
    function noise2d(x,z){
      const s = Math.sin(x*127.1 + z*311.7)*43758.5453;
      return s - Math.floor(s);
    }

    for(let x=-HALF; x<HALF; x++){
      for(let z=-HALF; z<HALF; z++){
        const hBase = 4 + Math.floor(noise2d(x*0.3, z*0.3)*5);
        for(let y=0; y<hBase; y++){
          let typeId = 1;
          if(y === hBase-1) typeId = 0;
          if(y < hBase-3)   typeId = 2;
          if(noise2d(x*0.7,z*0.7)>0.86 && y<hBase-2) typeId = 7;
          addBlock(x,y,z,typeId);
        }
        if (hBase <= 4 && noise2d(x,z) > 0.35) addBlock(x,hBase,z,3);
      }
    }

    function addTreeAt(x,z){
      let yTop = 0;
      for(let y=12;y>=0;y--){
        if(worldBlocks.has(keyFromXYZ(x,y,z))){ yTop = y+1; break; }
      }
      for(let i=0;i<4;i++) addBlock(x,yTop+i,z,4);
      const cy = yTop+3;
      for(let dx=-2;dx<=2;dx++){
        for(let dz=-2;dz<=2;dz++){
          for(let dy=0;dy<=2;dy++){
            if (Math.abs(dx)+Math.abs(dz)+Math.abs(dy) <= 4) {
              addBlock(x+dx, cy+dy, z+dz, 5);
            }
          }
        }
      }
    }
    for(let i=0;i<12;i++){
      const tx = Math.floor((Math.random()*WORLD_SIZE)-HALF);
      const tz = Math.floor((Math.random()*WORLD_SIZE)-HALF);
      addTreeAt(tx,tz);
    }

    // Lake
    const lakeRadius = 6;
    for(let x=-lakeRadius; x<=lakeRadius; x++){
      for(let z=-lakeRadius; z<=lakeRadius; z++){
        if(x*x + z*z <= lakeRadius*lakeRadius){
          const wx=x, wz=z;
          for(let y=0; y<6; y++) removeBlock(wx,y,wz);
          addBlock(wx,0,wz,6);
          addBlock(wx,1,wz,9);
        }
      }
    }

    // ===== Collisions =====
    const PLAYER_RADIUS = 0.35;
    function isPositionColliding(pos){
      const r = PLAYER_RADIUS;
      const r2 = r*r;
      const minX = Math.floor(pos.x - r);
      const maxX = Math.floor(pos.x + r);
      const minY = Math.floor(pos.y - r);
      const maxY = Math.floor(pos.y + r);
      const minZ = Math.floor(pos.z - r);
      const maxZ = Math.floor(pos.z + r);

      for(let x=minX; x<=maxX; x++){
        for(let y=minY; y<=maxY; y++){
          for(let z=minZ; z<=maxZ; z++){
            const m = worldBlocks.get(keyFromXYZ(x,y,z));
            if(!m) continue;

            const bx = x, by = y, bz = z;
            const closestX = Math.max(bx, Math.min(pos.x, bx+1));
            const closestY = Math.max(by, Math.min(pos.y, by+1));
            const closestZ = Math.max(bz, Math.min(pos.z, bz+1));
            const dx = pos.x - closestX;
            const dy = pos.y - closestY;
            const dz = pos.z - closestZ;
            if (dx*dx + dy*dy + dz*dz < r2) return true;
          }
        }
      }
      return false;
    }

    // ===== Flight movement =====
    const direction = new THREE.Vector3();
    const forwardFlat = new THREE.Vector3();
    const rightFlat = new THREE.Vector3();
    const moveForward = { value:0 }, moveRight = { value:0 }, moveUp = { value:0 };
    const keyState = {};

    let joyForward = 0, joyRight = 0, joyUp = 0;

    function onKey(e,down){ keyState[e.code] = down; }
    window.addEventListener('keydown', e => onKey(e,true));
    window.addEventListener('keyup',   e => onKey(e,false));

    function updateMovement(delta){
      let f = 0, r = 0, u = 0;
      if(keyState['KeyW'] || keyState['ArrowUp'])    f += 1;
      if(keyState['KeyS'] || keyState['ArrowDown'])  f -= 1;
      if(keyState['KeyA'] || keyState['ArrowLeft'])  r -= 1;
      if(keyState['KeyD'] || keyState['ArrowRight']) r += 1;
      if(keyState['Space'])                          u += 1;
      if(keyState['ShiftLeft'] || keyState['ShiftRight']) u -= 1;

      f += joyForward; r += joyRight; u += joyUp;

      f = Math.max(-1, Math.min(1, f));
      r = Math.max(-1, Math.min(1, r));
      u = Math.max(-1, Math.min(1, u));

      moveForward.value = f;
      moveRight.value   = r;
      moveUp.value      = u;

      direction.set(0,0,0);
      forwardFlat.set(0,0,-1).applyEuler(new THREE.Euler(0, yaw, 0, 'YXZ')).normalize();
      rightFlat.crossVectors(forwardFlat, new THREE.Vector3(0,1,0)).normalize();

      if(moveForward.value) direction.addScaledVector(forwardFlat, moveForward.value);
      if(moveRight.value)   direction.addScaledVector(rightFlat, moveRight.value);
      if(moveUp.value)      direction.y += moveUp.value;

      if(direction.lengthSq() > 0) direction.normalize();

      const SPEED = 18;
      const move = direction.multiplyScalar(SPEED * delta);

      const newPos = player.position.clone();

      newPos.x += move.x;
      if(isPositionColliding(newPos)) newPos.x = player.position.x;

      newPos.y += move.y;
      if(isPositionColliding(newPos)) newPos.y = player.position.y;

      newPos.z += move.z;
      if(isPositionColliding(newPos)) newPos.z = player.position.z;

      player.position.copy(newPos);
    }

    // ===== UI: hotbar + inventory =====
    let currentBlockIndex = 0;
    let editMode = 'remove';

    const hotbar = document.getElementById('hotbar');
    const posEl = document.getElementById('pos');
    const blockNameEl = document.getElementById('blockName');
    const modeToggle = document.getElementById('modeToggle');
    const modeText = document.getElementById('modeText');
    const modeIcon = modeToggle.querySelector('.icon');

    const invBtn = document.getElementById('invBtn');
    const invOverlay = document.getElementById('invOverlay');
    const invClose = document.getElementById('invClose');
    const invGrid = document.getElementById('invGrid');
    let inventoryOpen = false;

    function updateModeUI(){
      if(editMode === 'remove'){
        modeText.textContent = '–†–µ–∂–∏–º: –ª–æ–º–∞—Ç—å';
        modeIcon.textContent = 'üß±';
      } else {
        modeText.textContent = '–†–µ–∂–∏–º: —Å—Ç–∞–≤–∏—Ç—å';
        modeIcon.textContent = '‚ûï';
      }
    }
    updateModeUI();

    function openInventory(){
      inventoryOpen = true;
      invOverlay.style.display = 'block';
      buildInventoryGrid();
      buildHotbar();
    }
    function closeInventory(){
      inventoryOpen = false;
      invOverlay.style.display = 'none';
    }
    function toggleInventory(){
      inventoryOpen ? closeInventory() : openInventory();
    }

    invBtn.addEventListener('click', (e) => { e.preventDefault(); toggleInventory(); });
    invBtn.addEventListener('touchstart', (e) => { e.preventDefault(); toggleInventory(); }, {passive:false});
    invClose.addEventListener('click', (e) => { e.preventDefault(); closeInventory(); });
    invClose.addEventListener('touchstart', (e) => { e.preventDefault(); closeInventory(); }, {passive:false});
    invOverlay.addEventListener('click', (e) => {
      if(e.target === invOverlay) closeInventory();
    });

    // keyboard toggle: E
    window.addEventListener('keydown', (e) => {
      if(e.code === 'KeyE'){
        toggleInventory();
      }
    });

    modeToggle.addEventListener('click', () => {
      editMode = (editMode === 'remove') ? 'place' : 'remove';
      updateModeUI();
    });
    modeToggle.addEventListener('touchstart', (e) => {
      e.preventDefault();
      editMode = (editMode === 'remove') ? 'place' : 'remove';
      updateModeUI();
    }, {passive:false});

    function buildHotbar(){
      hotbar.innerHTML = '';
      blockTypes.forEach((t,i)=>{
        const slot = document.createElement('div');
        slot.className = 'slot' + (i===currentBlockIndex ? ' active' : '');
        slot.dataset.index = i;

        const col = document.createElement('div');
        col.className = 'color';
        const hex = '#' + t.color.toString(16).padStart(6,'0');
        col.style.background = t.isWater
          ? `linear-gradient(135deg, ${hex}, #8fc4ff)`
          : `linear-gradient(135deg, ${hex}, #ffffff40)`;
        slot.appendChild(col);

        const num = document.createElement('span');
        num.className = 'num';
        num.textContent = i+1;
        slot.appendChild(num);

        const cnt = document.createElement('span');
        cnt.className = 'cnt';
        cnt.textContent = getCount(t.id);
        slot.appendChild(cnt);

        hotbar.appendChild(slot);
      });
      blockNameEl.textContent = blockTypes[currentBlockIndex].name;
    }

    function buildInventoryGrid(){
      invGrid.innerHTML = '';
      for(let i=0;i<blockTypes.length;i++){
        const t = blockTypes[i];
        const item = document.createElement('div');
        item.className = 'invItem' + (i===currentBlockIndex ? ' active' : '');
        item.dataset.index = i;

        const sw = document.createElement('div');
        sw.className = 'invSwatch';
        const hex = '#' + t.color.toString(16).padStart(6,'0');
        sw.style.background = t.isWater
          ? `linear-gradient(135deg, ${hex}, #8fc4ff)`
          : `linear-gradient(135deg, ${hex}, #ffffff40)`;

        const meta = document.createElement('div');
        meta.className = 'invMeta';
        const name = document.createElement('div');
        name.className = 'invName';
        name.textContent = t.name;
        const count = document.createElement('div');
        count.className = 'invCount';
        count.textContent = `–ö–æ–ª-–≤–æ: ${getCount(t.id)}`;

        meta.appendChild(name);
        meta.appendChild(count);

        item.appendChild(sw);
        item.appendChild(meta);
        invGrid.appendChild(item);
      }
    }

    function selectBlockIndex(idx){
      if(idx < 0 || idx >= blockTypes.length) return;
      currentBlockIndex = idx;
      buildHotbar();
      if(inventoryOpen) buildInventoryGrid();
    }

    buildHotbar();

    // Hotbar selection
    function selectBlockFromSlot(slot){
      const idx = Number(slot.dataset.index);
      if(!Number.isNaN(idx)) selectBlockIndex(idx);
    }
    hotbar.addEventListener('click', (e) => {
      const slot = e.target.closest('.slot');
      if(!slot) return;
      selectBlockFromSlot(slot);
    });
    hotbar.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const slot = el && el.closest('.slot');
      if(!slot) return;
      selectBlockFromSlot(slot);
    }, {passive:false});

    // Inventory selection
    invGrid.addEventListener('click', (e) => {
      const item = e.target.closest('.invItem');
      if(!item) return;
      selectBlockIndex(Number(item.dataset.index));
    });
    invGrid.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const item = el && el.closest('.invItem');
      if(!item) return;
      selectBlockIndex(Number(item.dataset.index));
    }, {passive:false});

    // Wheel / digits (desktop)
    window.addEventListener('wheel', e => {
      if(inventoryOpen) return;
      const dir = Math.sign(e.deltaY);
      selectBlockIndex((currentBlockIndex + dir + blockTypes.length) % blockTypes.length);
    }, {passive:true});

    window.addEventListener('keydown', e => {
      if(e.code.startsWith('Digit')){
        const n = parseInt(e.code.slice(5),10);
        if(!isNaN(n) && n>=1 && n<=blockTypes.length) selectBlockIndex(n-1);
      }
    });

    // ===== Raycast edit =====
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(0,0);

    function getBlockIntersection(){
      raycaster.setFromCamera(pointer, camera);
      const objects = Array.from(worldBlocks.values());
      const intersects = raycaster.intersectObjects(objects, false);
      return intersects[0] || null;
    }

    function performEdit(action){
      if(inventoryOpen) return;

      const hit = getBlockIntersection();
      if(!hit) return;

      const hitPos = hit.object.position;
      const x = Math.floor(hitPos.x);
      const y = Math.floor(hitPos.y);
      const z = Math.floor(hitPos.z);

      if(action === 'remove'){
        const removedId = removeBlock(x,y,z);
        if(removedId !== null){
          addToInv(removedId, 1);
          buildHotbar();
          if(inventoryOpen) buildInventoryGrid();
        }
      } else if(action === 'place'){
        const blockId = blockTypes[currentBlockIndex].id;
        if(!canSpend(blockId, 1)) return; // –Ω–µ—Ç –±–ª–æ–∫–æ–≤

        const normal = hit.face.normal.clone();
        const placeX = Math.floor(hitPos.x + normal.x);
        const placeY = Math.floor(hitPos.y + normal.y);
        const placeZ = Math.floor(hitPos.z + normal.z);

        const key = keyFromXYZ(placeX,placeY,placeZ);
        if(worldBlocks.has(key)) return;

        // –Ω–µ —Å—Ç–∞–≤–∏–º –±–ª–æ–∫ "–≤–Ω—É—Ç—Ä—å –∏–≥—Ä–æ–∫–∞"
        const testPos = player.position.clone();
        if(
          placeX <= testPos.x && testPos.x <= placeX+1 &&
          placeY <= testPos.y && testPos.y <= placeY+1 &&
          placeZ <= testPos.z && testPos.z <= placeZ+1
        ){
          return;
        }

        const ok = addBlock(placeX,placeY,placeZ, blockId);
        if(ok){
          spend(blockId, 1);
          buildHotbar();
          if(inventoryOpen) buildInventoryGrid();
        }
      }
    }

    // Mouse: LMB remove, RMB place
    renderer.domElement.addEventListener('mousedown', (e) => {
      if (isTouchDevice) return;
      if(inventoryOpen) return;

      const isLeft = (e.button === 0);
      const isRight = (e.button === 2);
      if(!isLeft && !isRight) return;
      if(isLeft) performEdit('remove');
      else if(isRight) performEdit('place');
    });
    window.addEventListener('contextmenu', e => e.preventDefault());

    // ===== Touch joystick/buttons =====
    const joystick = document.getElementById('joystickLeft');
    const joystickHandle = document.getElementById('joystickHandle');
    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');

    let moveTouchId = null;
    let joyCenter = { x:0, y:0 };

    function updateJoyFromTouch(t){
      const rect = joystick.getBoundingClientRect();
      joyCenter.x = rect.left + rect.width/2;
      joyCenter.y = rect.top + rect.height/2;
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const maxR = rect.width/2;
      const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxR);
      const nx = dist ? dx/dist : 0;
      const ny = dist ? dy/dist : 0;
      const maxOffset = maxR - 25;

      joyRight = nx;
      joyForward = -ny;

      joystickHandle.style.transform = `translate(${nx * maxOffset}px, ${ny * maxOffset}px)`;
    }

    function resetJoystick(){
      joyForward = 0;
      joyRight = 0;
      joystickHandle.style.transform = 'translate(0,0)';
      moveTouchId = null;
    }

    if (isTouchDevice) {
      joystick.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.changedTouches[0];
        moveTouchId = t.identifier;
        updateJoyFromTouch(t);
      }, {passive:false});

      joystick.addEventListener('touchmove', e => {
        e.preventDefault();
        for(const t of e.changedTouches){
          if(t.identifier === moveTouchId){ updateJoyFromTouch(t); break; }
        }
      }, {passive:false});

      joystick.addEventListener('touchend', e => {
        for(const t of e.changedTouches){
          if(t.identifier === moveTouchId){ resetJoystick(); break; }
        }
      });
      joystick.addEventListener('touchcancel', e => {
        for(const t of e.changedTouches){
          if(t.identifier === moveTouchId){ resetJoystick(); break; }
        }
      });

      btnUp.addEventListener('touchstart', e => { e.preventDefault(); joyUp = 1; }, {passive:false});
      btnUp.addEventListener('touchend',   () => { joyUp = 0; });
      btnUp.addEventListener('touchcancel',() => { joyUp = 0; });

      btnDown.addEventListener('touchstart', e => { e.preventDefault(); joyUp = -1; }, {passive:false});
      btnDown.addEventListener('touchend',   () => { joyUp = 0; });
      btnDown.addEventListener('touchcancel',() => { joyUp = 0; });
    }

    // ===== Touch look + tap edit =====
    let lookTouchId = null;
    let lookStartX = 0;
    let lookStartY = 0;
    let lookInitX = 0;
    let lookInitY = 0;
    let lookStartTime = 0;

    if (isTouchDevice) {
      renderer.domElement.addEventListener('touchstart', e => {
        if(inventoryOpen) return;

        for(const t of e.changedTouches){
          const target = document.elementFromPoint(t.clientX, t.clientY);
          if (target && (
              target === joystick || joystick.contains(target) ||
              target === btnUp || target === btnDown ||
              target === hotbar || hotbar.contains(target) ||
              target === modeToggle || modeToggle.contains(target) ||
              target === invBtn || invBtn.contains(target)
          )) continue;

          if (lookTouchId === null) {
            lookTouchId = t.identifier;
            lookInitX = t.clientX; lookInitY = t.clientY;
            lookStartX = t.clientX; lookStartY = t.clientY;
            lookStartTime = performance.now();
            break;
          }
        }
      }, {passive:true});

      renderer.domElement.addEventListener('touchmove', e => {
        if(inventoryOpen) return;

        for(const t of e.changedTouches){
          if(t.identifier === lookTouchId){
            const dx = t.clientX - lookStartX;
            const dy = t.clientY - lookStartY;
            const sensitivity = 0.003;
            yaw   -= dx * sensitivity;
            pitch -= dy * sensitivity;
            pitch = Math.max(-PI_2 + 0.1, Math.min(PI_2 - 0.1, pitch));
            yawPitchEuler.set(pitch, yaw, 0, 'YXZ');
            camera.quaternion.setFromEuler(yawPitchEuler);
            lookStartX = t.clientX; lookStartY = t.clientY;
            e.preventDefault();
            break;
          }
        }
      }, {passive:false});

      renderer.domElement.addEventListener('touchend', e => {
        for(const t of e.changedTouches){
          if(t.identifier === lookTouchId){
            const dt = performance.now() - lookStartTime;
            const dxTotal = t.clientX - lookInitX;
            const dyTotal = t.clientY - lookInitY;
            const dist2 = dxTotal*dxTotal + dyTotal*dyTotal;

            const target = document.elementFromPoint(t.clientX, t.clientY);
            const isUI = target && (
              target === joystick || joystick.contains(target) ||
              target === btnUp || target === btnDown ||
              target === hotbar || hotbar.contains(target) ||
              target === modeToggle || modeToggle.contains(target) ||
              target === invBtn || invBtn.contains(target) ||
              target === invOverlay || invOverlay.contains(target)
            );

            if(!inventoryOpen && !isUI && dt < 250 && dist2 < 15*15){
              performEdit(editMode);
            }

            lookTouchId = null;
            break;
          }
        }
      });

      renderer.domElement.addEventListener('touchcancel', e => {
        for(const t of e.changedTouches){
          if(t.identifier === lookTouchId){ lookTouchId = null; break; }
        }
      });
    }

    // ===== Render loop =====
    let prevTime = performance.now();
    function animate(now){
      const delta = Math.min(0.05, (now - prevTime)/1000);
      prevTime = now;

      updateMovement(delta);

      const p = player.position;
      posEl.textContent = `${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // initial inventory grid ready
    buildInventoryGrid();
  })();
  </script>
</body>
</html>